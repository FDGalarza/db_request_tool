
import pandas as pd
import openpyxl
# =========================
# Generador de plantillas Excel
# =========================
from openpyxl import Workbook
from openpyxl.styles import Font, Alignment, Border, Side, PatternFill

from django.core.files.storage import default_storage
from django.core.mail import EmailMessage
from django.conf import settings
from django.template.loader import render_to_string
from .models import ConfiguracionEstructuraExcel
import os
import json
import secrets
import string
import re


# =========================
# Mapeo de sintaxis por motor de BD
# =========================
def get_tipo_dato_por_motor(tipo_dato, motor_bd):
    """
    Convierte tipos de datos genericos a la sintaxis especifica del motor
    """
    tipo_dato_lower = tipo_dato.lower().strip()
    
    mapeo = {
        'postgresql': {
            'varchar': 'character varying',
            'int': 'integer',
            'bigint': 'bigint',
            'smallint': 'smallint',
            'float': 'double precision',
            'double': 'double precision',
            'decimal': 'numeric',
            'boolean': 'boolean',
            'bool': 'boolean',
            'date': 'date',
            'datetime': 'timestamp',
            'timestamp': 'timestamp',
            'text': 'text',
            'blob': 'bytea',
            'serial': 'serial',
            'bigserial': 'bigserial',
        },
        'mysql': {
            'character varying': 'varchar',
            'integer': 'int',
            'bigint': 'bigint',
            'smallint': 'smallint',
            'double precision': 'double',
            'numeric': 'decimal',
            'boolean': 'tinyint(1)',
            'bool': 'tinyint(1)',
            'date': 'date',
            'timestamp': 'datetime',
            'text': 'text',
            'bytea': 'blob',
            'serial': 'int auto_increment',
            'bigserial': 'bigint auto_increment',
        },
        'sqlserver': {
            'character varying': 'nvarchar',
            'varchar': 'nvarchar',
            'integer': 'int',
            'bigint': 'bigint',
            'smallint': 'smallint',
            'double precision': 'float',
            'numeric': 'decimal',
            'boolean': 'bit',
            'bool': 'bit',
            'date': 'date',
            'timestamp': 'datetime2',
            'datetime': 'datetime2',
            'text': 'nvarchar(max)',
            'bytea': 'varbinary(max)',
            'serial': 'int identity(1,1)',
            'bigserial': 'bigint identity(1,1)',
        },
        'oracle': {
            'character varying': 'varchar2',
            'varchar': 'varchar2',
            'integer': 'number(10)',
            'int': 'number(10)',
            'bigint': 'number(19)',
            'smallint': 'number(5)',
            'double precision': 'binary_double',
            'float': 'binary_float',
            'numeric': 'number',
            'decimal': 'number',
            'boolean': 'number(1)',
            'bool': 'number(1)',
            'date': 'date',
            'timestamp': 'timestamp',
            'datetime': 'timestamp',
            'text': 'clob',
            'bytea': 'blob',
            'serial': 'number generated by default as identity',
            'bigserial': 'number generated by default as identity',
        },
        'sqlite': {
            'character varying': 'text',
            'varchar': 'text',
            'integer': 'integer',
            'int': 'integer',
            'bigint': 'integer',
            'smallint': 'integer',
            'double precision': 'real',
            'float': 'real',
            'numeric': 'numeric',
            'decimal': 'numeric',
            'boolean': 'integer',
            'bool': 'integer',
            'date': 'text',
            'timestamp': 'text',
            'datetime': 'text',
            'text': 'text',
            'bytea': 'blob',
            'serial': 'integer primary key autoincrement',
            'bigserial': 'integer primary key autoincrement',
        }
    }
    
    motor_mapeo = mapeo.get(motor_bd, mapeo['postgresql'])
    return motor_mapeo.get(tipo_dato_lower, tipo_dato)


def get_sintaxis_use_db(base_datos, motor_bd):
    """Retorna la sintaxis USE para cada motor"""
    if motor_bd == 'postgresql':
        return f"\\c {base_datos};"
    elif motor_bd == 'mysql':
        return f"USE `{base_datos}`;"
    elif motor_bd == 'sqlserver':
        return f"USE [{base_datos}];\nGO"
    elif motor_bd == 'oracle':
        return f"-- Conectar a: {base_datos}"
    elif motor_bd == 'sqlite':
        return f"-- Base de datos: {base_datos}"
    return f"USE {base_datos};"


def get_sintaxis_create_table(esquema, nombre_tabla, motor_bd):
    """Retorna la sintaxis CREATE TABLE para cada motor"""
    if motor_bd == 'postgresql':
        return f"CREATE TABLE {esquema}.{nombre_tabla}"
    elif motor_bd == 'mysql':
        return f"CREATE TABLE `{esquema}`.`{nombre_tabla}`"
    elif motor_bd == 'sqlserver':
        return f"CREATE TABLE [{esquema}].[{nombre_tabla}]"
    elif motor_bd == 'oracle':
        return f"CREATE TABLE {esquema}.{nombre_tabla}"
    elif motor_bd == 'sqlite':
        return f"CREATE TABLE {nombre_tabla}"
    return f"CREATE TABLE {esquema}.{nombre_tabla}"


def get_sintaxis_alter_table(esquema, nombre_tabla, motor_bd):
    """Retorna la sintaxis ALTER TABLE para cada motor"""
    if motor_bd == 'postgresql':
        return f"ALTER TABLE {esquema}.{nombre_tabla}"
    elif motor_bd == 'mysql':
        return f"ALTER TABLE `{esquema}`.`{nombre_tabla}`"
    elif motor_bd == 'sqlserver':
        return f"ALTER TABLE [{esquema}].[{nombre_tabla}]"
    elif motor_bd == 'oracle':
        return f"ALTER TABLE {esquema}.{nombre_tabla}"
    elif motor_bd == 'sqlite':
        return f"ALTER TABLE {nombre_tabla}"
    return f"ALTER TABLE {esquema}.{nombre_tabla}"


def get_sintaxis_add_column(nombre_col, tipo_dato, motor_bd):
    """Retorna la sintaxis ADD COLUMN para cada motor"""
    if motor_bd == 'postgresql':
        return f"ADD COLUMN {nombre_col} {tipo_dato}"
    elif motor_bd == 'mysql':
        return f"ADD COLUMN `{nombre_col}` {tipo_dato}"
    elif motor_bd == 'sqlserver':
        return f"ADD [{nombre_col}] {tipo_dato}"
    elif motor_bd == 'oracle':
        return f"ADD ({nombre_col} {tipo_dato})"
    elif motor_bd == 'sqlite':
        return f"ADD COLUMN {nombre_col} {tipo_dato}"
    return f"ADD COLUMN {nombre_col} {tipo_dato}"


def get_sintaxis_drop_column(nombre_col, motor_bd):
    """Retorna la sintaxis DROP COLUMN para cada motor"""
    if motor_bd == 'postgresql':
        return f"DROP COLUMN {nombre_col}"
    elif motor_bd == 'mysql':
        return f"DROP COLUMN `{nombre_col}`"
    elif motor_bd == 'sqlserver':
        return f"DROP COLUMN [{nombre_col}]"
    elif motor_bd == 'oracle':
        return f"DROP ({nombre_col})"
    elif motor_bd == 'sqlite':
        return f"DROP COLUMN {nombre_col}"
    return f"DROP COLUMN {nombre_col}"


def get_sintaxis_modify_column(nombre_col, tipo_dato, motor_bd):
    """Retorna la sintaxis MODIFY COLUMN para cada motor"""
    if motor_bd == 'postgresql':
        return f"ALTER COLUMN {nombre_col} TYPE {tipo_dato}"
    elif motor_bd == 'mysql':
        return f"MODIFY COLUMN `{nombre_col}` {tipo_dato}"
    elif motor_bd == 'sqlserver':
        return f"ALTER COLUMN [{nombre_col}] {tipo_dato}"
    elif motor_bd == 'oracle':
        return f"MODIFY ({nombre_col} {tipo_dato})"
    elif motor_bd == 'sqlite':
        return f"-- SQLite no soporta MODIFY COLUMN directamente para {nombre_col}"
    return f"MODIFY COLUMN {nombre_col} {tipo_dato}"


def get_sintaxis_primary_key(columnas, nombre_pk, motor_bd):
    """Retorna la sintaxis PRIMARY KEY para cada motor"""
    cols_str = ', '.join(columnas)
    constraint_name = nombre_pk or f"pk_{'_'.join(columnas)}"
    
    if motor_bd == 'postgresql':
        return f"CONSTRAINT {constraint_name} PRIMARY KEY ({cols_str})"
    elif motor_bd == 'mysql':
        return f"PRIMARY KEY ({cols_str})"
    elif motor_bd == 'sqlserver':
        return f"CONSTRAINT [{constraint_name}] PRIMARY KEY ({cols_str})"
    elif motor_bd == 'oracle':
        return f"CONSTRAINT {constraint_name} PRIMARY KEY ({cols_str})"
    elif motor_bd == 'sqlite':
        return f"PRIMARY KEY ({cols_str})"
    return f"PRIMARY KEY ({cols_str})"


def get_sintaxis_foreign_key(columna, tabla_ref, motor_bd):
    """Retorna la sintaxis FOREIGN KEY para cada motor"""
    if motor_bd == 'postgresql':
        return f"FOREIGN KEY ({columna}) REFERENCES {tabla_ref}"
    elif motor_bd == 'mysql':
        return f"FOREIGN KEY (`{columna}`) REFERENCES {tabla_ref}"
    elif motor_bd == 'sqlserver':
        return f"FOREIGN KEY ([{columna}]) REFERENCES {tabla_ref}"
    elif motor_bd == 'oracle':
        return f"FOREIGN KEY ({columna}) REFERENCES {tabla_ref}"
    elif motor_bd == 'sqlite':
        return f"FOREIGN KEY ({columna}) REFERENCES {tabla_ref}"
    return f"FOREIGN KEY ({columna}) REFERENCES {tabla_ref}"


def get_sintaxis_comment_table(esquema, nombre_tabla, comentario, motor_bd):
    """Retorna la sintaxis COMMENT para tablas"""
    if motor_bd == 'postgresql':
        return f"COMMENT ON TABLE {esquema}.{nombre_tabla} IS '{comentario}';"
    elif motor_bd == 'mysql':
        return f"ALTER TABLE `{esquema}`.`{nombre_tabla}` COMMENT = '{comentario}';"
    elif motor_bd == 'sqlserver':
        return f"EXEC sp_addextendedproperty 'MS_Description', '{comentario}', 'SCHEMA', '{esquema}', 'TABLE', '{nombre_tabla}';"
    elif motor_bd == 'oracle':
        return f"COMMENT ON TABLE {esquema}.{nombre_tabla} IS '{comentario}';"
    elif motor_bd == 'sqlite':
        return f"-- Comentario tabla: {comentario}"
    return f"-- Comentario: {comentario}"


def get_sintaxis_comment_column(esquema, nombre_tabla, nombre_col, comentario, motor_bd):
    """Retorna la sintaxis COMMENT para columnas"""
    if motor_bd == 'postgresql':
        return f"COMMENT ON COLUMN {esquema}.{nombre_tabla}.{nombre_col} IS '{comentario}';"
    elif motor_bd == 'mysql':
        return f"-- MySQL: comentario de columna agregado en definicion"
    elif motor_bd == 'sqlserver':
        return f"EXEC sp_addextendedproperty 'MS_Description', '{comentario}', 'SCHEMA', '{esquema}', 'TABLE', '{nombre_tabla}', 'COLUMN', '{nombre_col}';"
    elif motor_bd == 'oracle':
        return f"COMMENT ON COLUMN {esquema}.{nombre_tabla}.{nombre_col} IS '{comentario}';"
    elif motor_bd == 'sqlite':
        return f"-- Comentario columna {nombre_col}: {comentario}"
    return f"-- Comentario {nombre_col}: {comentario}"


def get_encabezado_script(motor_bd):
    """Retorna encabezado del script segun el motor"""
    headers = {
        'postgresql': "-- PostgreSQL Script\n-- Generado automaticamente\n",
        'mysql': "-- MySQL Script\n-- Generado automaticamente\nSET NAMES utf8mb4;\nSET FOREIGN_KEY_CHECKS = 0;\n",
        'sqlserver': "-- SQL Server Script\n-- Generado automaticamente\nSET ANSI_NULLS ON;\nGO\nSET QUOTED_IDENTIFIER ON;\nGO\n",
        'oracle': "-- Oracle Script\n-- Generado automaticamente\nSET DEFINE OFF;\n",
        'sqlite': "-- SQLite Script\n-- Generado automaticamente\nPRAGMA foreign_keys = ON;\n"
    }
    return headers.get(motor_bd, "-- SQL Script\n")


def get_sintaxis_create_user(nombre_usuario, motor_bd):
    """Retorna la sintaxis CREATE USER para cada motor"""
    if motor_bd == 'postgresql':
        return f"CREATE USER {nombre_usuario} WITH PASSWORD 'password';"
    elif motor_bd == 'mysql':
        return f"CREATE USER '{nombre_usuario}'@'%' IDENTIFIED BY 'password';"
    elif motor_bd == 'sqlserver':
        return f"CREATE LOGIN [{nombre_usuario}] WITH PASSWORD = 'password';\nCREATE USER [{nombre_usuario}] FOR LOGIN [{nombre_usuario}];\nGO"
    elif motor_bd == 'oracle':
        return f"CREATE USER {nombre_usuario} IDENTIFIED BY password;"
    elif motor_bd == 'sqlite':
        return f"-- SQLite no soporta CREATE USER"
    return f"CREATE USER {nombre_usuario} IDENTIFIED BY 'password';"


def get_sintaxis_grant(permisos, esquema, tabla, nombre_usuario, motor_bd):
    """Retorna la sintaxis GRANT para cada motor"""
    if motor_bd == 'postgresql':
        return f"GRANT {permisos} ON {esquema}.{tabla} TO {nombre_usuario};"
    elif motor_bd == 'mysql':
        return f"GRANT {permisos} ON `{esquema}`.`{tabla}` TO '{nombre_usuario}'@'%';"
    elif motor_bd == 'sqlserver':
        return f"GRANT {permisos} ON [{esquema}].[{tabla}] TO [{nombre_usuario}];\nGO"
    elif motor_bd == 'oracle':
        return f"GRANT {permisos} ON {esquema}.{tabla} TO {nombre_usuario};"
    elif motor_bd == 'sqlite':
        return f"-- SQLite no soporta GRANT"
    return f"GRANT {permisos} ON {esquema}.{tabla} TO {nombre_usuario};"


def get_sintaxis_create_database(nombre_bd, charset, collation, motor_bd):
    """Retorna la sintaxis CREATE DATABASE para cada motor"""
    if motor_bd == 'postgresql':
        return f"CREATE DATABASE {nombre_bd} ENCODING '{charset}' LC_COLLATE '{collation}';"
    elif motor_bd == 'mysql':
        return f"CREATE DATABASE `{nombre_bd}` CHARACTER SET {charset} COLLATE {collation};"
    elif motor_bd == 'sqlserver':
        return f"CREATE DATABASE [{nombre_bd}] COLLATE {collation};\nGO"
    elif motor_bd == 'oracle':
        return f"-- Oracle: CREATE TABLESPACE o conectar a {nombre_bd}"
    elif motor_bd == 'sqlite':
        return f"-- SQLite: La base de datos es el archivo {nombre_bd}.db"
    return f"CREATE DATABASE {nombre_bd} CHARACTER SET {charset} COLLATE {collation};"


def get_sintaxis_create_schema(nombre_esquema, propietario, motor_bd):
    """Retorna la sintaxis CREATE SCHEMA para cada motor"""
    if motor_bd == 'postgresql':
        return f"CREATE SCHEMA {nombre_esquema} AUTHORIZATION {propietario};"
    elif motor_bd == 'mysql':
        return f"CREATE DATABASE `{nombre_esquema}`; -- MySQL usa DATABASE en lugar de SCHEMA"
    elif motor_bd == 'sqlserver':
        return f"CREATE SCHEMA [{nombre_esquema}] AUTHORIZATION [{propietario}];\nGO"
    elif motor_bd == 'oracle':
        return f"CREATE USER {nombre_esquema} IDENTIFIED BY password DEFAULT TABLESPACE users;"
    elif motor_bd == 'sqlite':
        return f"-- SQLite no soporta esquemas"
    return f"CREATE SCHEMA {nombre_esquema} AUTHORIZATION {propietario};"


# =========================
# Lectura del Excel
# =========================
def procesar_archivo_excel(solicitud):
    
    """
    Procesa archivos Excel segun el tipo de solicitud y genera scripts SQL
    """
    if not solicitud.archivo_adjunto:
        return None

    try:
        file_path = solicitud.archivo_adjunto.path
        df = pd.read_excel(file_path)

        # Obtener motor de BD del proyecto
        motor_bd = 'postgresql'  # default
        if solicitud.proyecto and solicitud.proyecto.motor_bd:
            motor_bd = solicitud.proyecto.motor_bd

        if solicitud.tipo_solicitud in ['crear_tabla', 'modificar_tabla']:
            return generar_script_tabla(df, solicitud.tipo_solicitud, solicitud.base_datos_aplicacion, motor_bd)
        elif solicitud.tipo_solicitud in ['asignar_permisos', 'crear_usuarios']:
            return generar_script_permisos_usuarios(file_path, motor_bd)
        elif solicitud.tipo_solicitud in ['crear_bd', 'crear_esquemas']:
            return generar_script_bd_esquemas(df, solicitud.tipo_solicitud, solicitud.base_datos_aplicacion, motor_bd)

    except Exception as e:
        import traceback
        traceback.print_exc()
        return f"-- Error procesando archivo: {str(e)}"

    return None

def validar_estructura_excel(archivo, tipo_solicitud):
    """
    Valida la estructura del archivo Excel segun el tipo de solicitud.
    Soporta validacion especial para crear_tabla y crear_usuarios.
    """
    try:
        if tipo_solicitud == 'crear_tabla':
            df = pd.read_excel(archivo)
            return validar_estructura_crear_tabla(df)

        elif tipo_solicitud == 'crear_usuarios':
            # Leer los metadatos (primeras 3 filas)
            metadata = pd.read_excel(archivo, nrows=3, header=None)

            # Verificar contenido de los metadatos
            campos_esperados = ['Nombre Usuario', 'base de datos', 'Es usuario Nuevo']
            for i, campo in enumerate(campos_esperados):
                valor = str(metadata.iloc[i, 0]).strip().lower()
                if valor != campo.strip().lower():
                    return False, f"Se esperaba '{campo}' en la fila {i+1}, columna A"

            # Verificar que las celdas de valor no esten vacias
            for i in range(3):
                if pd.isna(metadata.iloc[i, 1]) or str(metadata.iloc[i, 1]).strip() == "":
                    return False, f"El valor de '{campos_esperados[i]}' no puede estar vacio"

            # Leer tabla de permisos (a partir de la fila 5, es decir, indice 4)
            df_permisos = pd.read_excel(archivo, skiprows=4)

            columnas_requeridas = ['Esquema', 'Nombre Tabla', 'Select', 'Insert', 'Update', 'Delete']
            columnas_df = [str(col).strip().lower() for col in df_permisos.columns]
            faltantes = [col for col in columnas_requeridas if col.lower() not in columnas_df]

            if faltantes:
                return False, f"Faltan las siguientes columnas en la tabla de permisos: {', '.join(faltantes)}"

            if df_permisos.empty:
                return False, "La tabla de permisos esta vacia"

            return True, "Estructura valida para creacion de usuarios"

        else:
            # Para otros tipos, usar la configuracion del modelo
            df = pd.read_excel(archivo)

            try:
                config = ConfiguracionEstructuraExcel.objects.get(tipo_solicitud=tipo_solicitud)
                estructura_esperada = config.get_estructura()
            except ConfiguracionEstructuraExcel.DoesNotExist:
                estructura_esperada = obtener_estructura_por_defecto(tipo_solicitud)

            columnas_requeridas = estructura_esperada.get('columnas_requeridas', [])
            columnas_encontradas = buscar_columnas_flexibles(df, columnas_requeridas)
            faltantes = [col for col in columnas_requeridas if col not in columnas_encontradas]

            if faltantes:
                return False, f"Faltan las siguientes columnas: {', '.join(faltantes)}"

            if df.empty:
                return False, "El archivo no contiene datos"

            return True, f"Estructura valida. Se encontraron {len(df)} filas de datos."

    except Exception as e:
        return False, f"Error al validar el archivo: {str(e)}"

    
def validar_estructura_crear_usuarios(df):
    """
    Valida que el archivo Excel para crear usuarios tenga la estructura correcta.
    Se espera que las primeras celdas contengan:
    - Nombre Usuario
    - base de datos
    - Es usuario Nuevo
    Y luego una tabla con permisos.
    """
    # Normalizamos los nombres de columna a lowercase sin espacios
    columnas = [str(col).strip().lower().replace(" ", "_") for col in df.columns]
    
    columnas_requeridas = ['esquema', 'nombre_tabla', 'select', 'insert', 'update', 'delete']
    columnas_faltantes = [col for col in columnas_requeridas if col not in columnas]
    
    if columnas_faltantes:
        return False, f"Faltan las columnas de permisos: {', '.join(columnas_faltantes)}"
    
    # validar que las celdas superiores esten llenas, si estas usando multiples hojas
    if df.empty or df.shape[0] == 0:
        return False, "El archivo esta vacio o no contiene datos en la tabla de permisos."
    
    return True, "Estructura valida para creacion de usuarios."


def buscar_columnas_flexibles(df, columnas_requeridas):
    """
    Busca columnas de manera flexible, considerando diferentes variaciones de nombres
    """
    columnas_encontradas = []
    
    # Mapeo de variaciones de nombres de columnas
    mapeo_columnas = {
        'nombre_usuario': ['nombre_usuario', 'nombre usuario', 'usuario', 'user', 'username'],
        'rol': ['rol', 'role', 'perfil', 'profile'],
        'permisos': ['permisos', 'permissions', 'privilegios', 'privileges'],
        'usuario': ['usuario', 'user', 'username', 'nombre_usuario'],
        'tabla': ['tabla', 'table', 'esquema', 'schema'],
        'nombre_bd': ['nombre_bd', 'nombre bd', 'database', 'base_datos', 'bd'],
        'charset': ['charset', 'character_set', 'codificacion', 'encoding'],
        'collation': ['collation', 'collate', 'cotejamiento'],
        'nombre_esquema': ['nombre_esquema', 'nombre esquema', 'schema', 'esquema'],
        'propietario': ['propietario', 'owner', 'dueno', 'usuario_propietario']
    }
    
    for col_requerida in columnas_requeridas:
        variaciones = mapeo_columnas.get(col_requerida, [col_requerida])
        
        for col_df in df.columns:
            col_df_lower = str(col_df).lower().strip()
            
            for variacion in variaciones:
                if variacion.lower() in col_df_lower or col_df_lower in variacion.lower():
                    columnas_encontradas.append(col_requerida)
                    break
            
            if col_requerida in columnas_encontradas:
                break
    
    return columnas_encontradas

def validar_estructura_crear_tabla(df):
    """
    Valida la estructura especifica para creacion de tablas - para buscar en contenido
    """
    try:
        # Verificar que tenga datos
        if df.empty:
            return False, "El archivo esta vacio"
        
        # Buscar headers en el contenido del DataFrame
        fila_headers, columnas_headers = encontrar_headers_en_contenido(df)
        
        # Verificar columnas minimas
        if 'nombre_columna' not in columnas_headers:
            return False, "No se encontro la columna de 'Nombre de la columna'. Verifique que el archivo tenga los headers correctos."
        
        if 'tipo_dato' not in columnas_headers:
            return False, "No se encontro la columna de 'Tipo de dato'. Verifique que el archivo tenga los headers correctos."
        
        # Contar filas con datos validos despues de los headers
        filas_validas = contar_filas_validas(df, fila_headers, columnas_headers)
        
        if filas_validas == 0:
            return False, "No se encontraron definiciones de columnas validas despues de los headers"
        
        return True, f"Estructura valida. Se encontraron {filas_validas} definiciones de columnas."
        
    except Exception as e:
        import traceback
        traceback.print_exc()
        return False, f"Error validando estructura: {str(e)}"

# =========================
# Busqueda de headers en el contenido
# =========================
def encontrar_headers_en_contenido(df):
    """
    Busca los headers dentro del contenido del DataFrame, no en los nombres de columnas.
    Detecta sinonimos y soporta 'tamano'/'tamano'/'tamanio'/'longitud'/'largo'/'size'.
    """
    columnas_headers = {}
    fila_headers = None

    # Mapeo de sinonimos -> clave
    synonyms = {
        "nombre_columna": {"nombre de la columna", "nombre_columna", "columna", "campo"},
        "accion": {"accion", "accion", "operacion", "operacion", "action"},
        "tipo_dato": {"tipo de dato", "tipo_dato", "tipo dato", "tipo", "data type"},
        "tamano": {"tamano", "tamano", "tamanio", "longitud", "largo", "size", "length"},
        "nullable": {"es nullable", "nullable", "acepta null", "null", "permite null"},
        "primaria": {"es llave primaria", "Es llave primaria", "llave primaria", "clave primaria", "primary key", "pk"},
        "nombre_pk": {"nombre pk", "nombre de la pk", "pk name"},
        "default": {"por defecto", "default", "valor defecto", "por por defecto", "defecto", "valor por defecto"},
        "foranea": {"es foranea", "Es foranea", "foranea", "foreign key", "fk", "foranea", "es foranea"},
        "referencia": {"tabla referencia", "referencia", "tabla_referencia", "tabla ref", "ref"},
        "comentario": {"comentario de campo", "comentario campo", "comentario", "descripcion", "descripcion"}
    }

    def normalize(s):
        return str(s).strip().lower()

    for i in range(len(df)):
        headers_temp = {}
        for j in range(len(df.columns)):
            val = df.iloc[i, j]
            if pd.isna(val):
                continue
            vs = normalize(val)
            # probar cada clave y sus sinonimos
            for key, words in synonyms.items():
                if vs in words:
                    headers_temp[key] = j

        # condicion minima: nombre_columna + (tipo_dato o accion)
        if ("nombre_columna" in headers_temp) and ("tipo_dato" in headers_temp or "accion" in headers_temp):
            fila_headers = i
            columnas_headers = headers_temp
            print(f"DEBUG: Fila de headers confirmada: {i} -> {columnas_headers}")
            break

    return fila_headers, columnas_headers


def contar_filas_validas(df, fila_headers, columnas_headers):
    """
    Cuenta filas validas despues de encontrar los headers
    """
    if fila_headers is None or 'nombre_columna' not in columnas_headers:
        return 0
    
    filas_validas = 0
    col_nombre = columnas_headers['nombre_columna']
    
    # Empezar a contar desde la fila siguiente a los headers
    inicio_datos = fila_headers + 1
    
    for idx in range(inicio_datos, len(df)):
        valor_nombre = df.iloc[idx, col_nombre]
        print(f"DEBUG: Fila {idx}, valor nombre: '{valor_nombre}', tipo: {type(valor_nombre)}")
        
        if pd.notna(valor_nombre):
            valor_str = str(valor_nombre).strip()
            # Excluir valores vacios y headers repetidos
            if (valor_str and 
                valor_str.lower() not in ['nombre de la columna', 'nombre_columna', 'nan', 'nombre tabla', 'comentario tabla'] and
                not valor_str.startswith('Unnamed') and
                len(valor_str) > 1):  # Al menos 2 caracteres
                filas_validas += 1
                print(f"DEBUG: Fila valida encontrada: {valor_str}")
    
    return filas_validas

def buscar_columnas_crear_tabla(df):
    """
    Busca columnas para crear_tabla - MEJORADA para buscar en contenido
    """
    # invoca funcion que busca en el contenido
    fila_headers, columnas_headers = encontrar_headers_en_contenido(df)
    return columnas_headers

def obtener_estructura_por_defecto(tipo_solicitud):
    """
    Retorna la estructura por defecto para cada tipo de solicitud - UNIFICADA
    """
    estructuras = {
        'crear_tabla': {
            'descripcion': 'Estructura para creacion de tablas con informacion completa',
            'columnas_requeridas': [
                'Nombre de la columna', 'Tipo de dato', 'Es nullable', 'Es llave primaria'
            ],
            'columnas_opcionales': [
                'por por defecto', 'es foranea', 'tabla referencia', 'Comentario de campo'
            ],
            'tipos_datos': {
                'Nombre de la columna': 'string',
                'Tipo de dato': 'string',
                'Es nullable': 'string',
                'por por defecto': 'string',
                'Es llave primaria': 'string',
                'es foranea': 'string',
                'tabla referencia': 'string',
                'Comentario de campo': 'string'
            }
        },
        'modificar_tabla': {
            'columnas_requeridas': ['nombre_tabla', 'nombre_columna', 'accion', 'tipo_dato'],
            'tipos_datos': {
                'nombre_tabla': 'string',
                'nombre_columna': 'string',
                'accion': 'string',
                'tipo_dato': 'string'
            }
        },
        'crear_usuarios': {
            'columnas_requeridas': ['nombre_usuario', 'rol', 'permisos'],
            'tipos_datos': {
                'nombre_usuario': 'string',
                'rol': 'string',
                'permisos': 'string'
            }
        },
        'asignar_permisos': {
            'columnas_requeridas': ['usuario', 'tabla', 'permisos'],
            'tipos_datos': {
                'usuario': 'string',
                'tabla': 'string',
                'permisos': 'string'
            }
        },
        'crear_bd': {
            'columnas_requeridas': ['nombre_bd', 'charset', 'collation'],
            'tipos_datos': {
                'nombre_bd': 'string',
                'charset': 'string',
                'collation': 'string'
            }
        },
        'crear_esquemas': {
            'columnas_requeridas': ['nombre_esquema', 'propietario'],
            'tipos_datos': {
                'nombre_esquema': 'string',
                'propietario': 'string'
            }
        }
    }
    
    return estructuras.get(tipo_solicitud, {'columnas_requeridas': [], 'tipos_datos': {}})

def validar_tipo_columna(serie, tipo_esperado):
    """
    Valida que una serie de pandas tenga el tipo de dato esperado
    """
    if tipo_esperado == 'string':
        return serie.dtype == 'object' or serie.dtype.name.startswith('str')
    elif tipo_esperado == 'number':
        return pd.api.types.is_numeric_dtype(serie)
    elif tipo_esperado == 'date':
        return pd.api.types.is_datetime64_any_dtype(serie)
    
    return True

# =========================
# Generador del script de tablas
# =========================
def generar_script_tabla(df, tipo_solicitud, base_datos, motor_bd='postgresql'):
    """
    Genera script SQL para creacion o modificacion de tablas.
    ACTUALIZADO: Maneja 'Accion' y 'Tamano' de la nueva estructura.
    Soporta multiples motores: postgresql, mysql, sqlserver, oracle, sqlite
    """
    try:
        script = get_encabezado_script(motor_bd)
        script += f"-- Tipo: {tipo_solicitud}\n"
        script += f"-- Base de datos: {base_datos}\n"
        script += f"-- Motor: {motor_bd.upper()}\n"
        script += f"-- Fecha: {pd.Timestamp.now().strftime('%Y-%m-%d %H:%M:%S')}\n\n"

        # Detectar nombre de tabla, esquema y comentario en primeras filas
        nombre_tabla = None
        comentario_tabla = None
        esquema = "public"  # default

        for i in range(min(6, len(df))):
            for j in range(len(df.columns)):
                valor = df.iloc[i, j]
                if pd.isna(valor):
                    continue
                v = str(valor).strip().lower()
                
                if v in {'nombre tabla', 'nombre_tabla'}:
                    # siguiente celda (derecha) o siguiente fila misma columna
                    if j + 1 < len(df.columns) and pd.notna(df.iloc[i, j+1]):
                        nombre_tabla = str(df.iloc[i, j+1]).strip()
                    elif i + 1 < len(df) and pd.notna(df.iloc[i+1, j]):
                        nombre_tabla = str(df.iloc[i+1, j]).strip()
                elif v in {'esquema', 'schema'}:
                    if j + 1 < len(df.columns) and pd.notna(df.iloc[i, j+1]):
                        esquema = str(df.iloc[i, j+1]).strip() or esquema
                    elif i + 1 < len(df) and pd.notna(df.iloc[i+1, j]):
                        esquema = str(df.iloc[i+1, j]).strip() or esquema
                elif 'comentario' in v:
                    if j + 1 < len(df.columns) and pd.notna(df.iloc[i, j+1]):
                        comentario_tabla = str(df.iloc[i, j+1]).strip()
                    elif i + 1 < len(df) and pd.notna(df.iloc[i+1, j]):
                        comentario_tabla = str(df.iloc[i+1, j]).strip()

        if not nombre_tabla:
            nombre_tabla = f"tabla_{base_datos.lower().replace(' ', '_')}"

        # Encontrar headers
        fila_headers, columnas_headers = encontrar_headers_en_contenido(df)

        if tipo_solicitud == 'crear_tabla':
            script += get_sintaxis_use_db(base_datos, motor_bd) + "\n\n"
            script += f"-- Tabla: {esquema}.{nombre_tabla}\n"
            if comentario_tabla:
                script += f"-- Comentario: {comentario_tabla}\n"
            script += get_sintaxis_create_table(esquema, nombre_tabla, motor_bd) + " (\n"

            columnas_sql = []
            claves_primarias = []
            claves_foraneas = []  # (col, tabla_ref)

            if fila_headers is not None and 'nombre_columna' in columnas_headers:
                inicio_datos = fila_headers + 1
                for i in range(inicio_datos, len(df)):
                    # Nombre columna
                    val_nombre = df.iloc[i, columnas_headers['nombre_columna']]
                    if pd.isna(val_nombre):
                        continue
                    nombre_col = str(val_nombre).strip()
                    if not nombre_col or nombre_col.lower().startswith('unnamed'):
                        continue

                    # Tipo
                    tipo_dato = 'varchar'
                    if 'tipo_dato' in columnas_headers:
                        tv = df.iloc[i, columnas_headers['tipo_dato']]
                        if pd.notna(tv):
                            tipo_dato = str(tv).strip() or 'varchar'

                    # Tamano
                    tamano_valor = None
                    if 'tamano' in columnas_headers:
                        tv = df.iloc[i, columnas_headers['tamano']]
                        if pd.notna(tv):
                            tamano_valor = tv
                    
                    tamano_str = _parse_tamano(tamano_valor)
                    tipo_dato = _tipo_con_tamano(tipo_dato, tamano_str)
                    
                    # Convertir tipo de dato segun el motor
                    tipo_dato = get_tipo_dato_por_motor(tipo_dato, motor_bd)

                    # Nullable
                    nullable = ""
                    if 'nullable' in columnas_headers:
                        nv = df.iloc[i, columnas_headers['nullable']]
                        if pd.notna(nv) and str(nv).strip().lower() in {'no', 'false', '0', 'n'}:
                            nullable = "NOT NULL"

                    # Default
                    default_val = ""
                    if 'default' in columnas_headers:
                        dv = df.iloc[i, columnas_headers['default']]
                        if pd.notna(dv):
                            d = str(dv).strip()
                            if d and d.lower() not in {'null', 'none', 'nan'}:
                                # funciones conocidas sin comillas
                                if '(' in d or ')' in d or d.upper() in {'CURRENT_TIMESTAMP', 'NOW()', 'UUID()'}:
                                    default_val = f"DEFAULT {d}"
                                else:
                                    default_val = f"DEFAULT '{d}'"

                    # Comentario inline
                    comentario = ""
                    if 'comentario' in columnas_headers:
                        cv = df.iloc[i, columnas_headers['comentario']]
                        if pd.notna(cv):
                            c = str(cv).strip()
                            if c and c.lower() not in {'comentario de campo', 'nan'}:
                                comentario = f"COMMENT '{c}'"

                    columnas_sql.append(
                        f"    {nombre_col} {tipo_dato} {nullable} {default_val} {comentario}".strip()
                    )

                    # PK
                    
                    if 'primaria' in columnas_headers:
                        pv = df.iloc[i, columnas_headers['primaria']]
                        if pd.notna(pv) and str(pv).strip().lower() in {'si', 'si', 'yes', '1', 'true', 'y'}:
                            
                            claves_primarias.append(nombre_col)

                    # FK
                    if 'foranea' in columnas_headers:
                        fv = df.iloc[i, columnas_headers['foranea']]
                        if pd.notna(fv) and str(fv).strip().lower() in {'si', 'si', 'yes', '1', 'true', 'y'}:
                            tabla_ref = None
                            if 'referencia' in columnas_headers:
                                rv = df.iloc[i, columnas_headers['referencia']]
                                if pd.notna(rv):
                                    tabla_ref = str(rv).strip()
                            if tabla_ref:
                                claves_foraneas.append((nombre_col, tabla_ref))

            # Cerrar definicion de columnas
            if columnas_sql:
                script += ",\n".join(columnas_sql)
            else:
                script += "    -- No se encontraron definiciones de columnas validas"

            # Constraints PK
            if claves_primarias:
                pk_constraint = get_sintaxis_primary_key(claves_primarias, f"pk_{nombre_tabla}", motor_bd)
                script += f",\n    {pk_constraint}"

            # FK
            for col_fk, tabla_ref in claves_foraneas:
                fk_constraint = get_sintaxis_foreign_key(col_fk, f"{tabla_ref}(id)", motor_bd)
                script += f",\n    CONSTRAINT fk_{col_fk} {fk_constraint}\n"
                script += f"        ON UPDATE NO ACTION\n"
                script += f"        ON DELETE NO ACTION"

            script += "\n);\n\n"

            # Comentario de tabla
            if comentario_tabla:
                script += get_sintaxis_comment_table(esquema, nombre_tabla, comentario_tabla, motor_bd) + "\n"

        elif tipo_solicitud == 'modificar_tabla':
            # Manejo de modificaciones con columna 'Accion'
            script += get_sintaxis_use_db(base_datos, motor_bd) + "\n\n"
            script += f"-- Modificaciones para tabla: {esquema}.{nombre_tabla}\n\n"

            if fila_headers is not None and 'nombre_columna' in columnas_headers:
                inicio_datos = fila_headers + 1
                for i in range(inicio_datos, len(df)):
                    # Nombre columna
                    val_nombre = df.iloc[i, columnas_headers['nombre_columna']]
                    if pd.isna(val_nombre):
                        continue
                    nombre_col = str(val_nombre).strip()
                    if not nombre_col:
                        continue

                    # Accion
                    accion = 'ADD'  # default
                    if 'accion' in columnas_headers:
                        av = df.iloc[i, columnas_headers['accion']]
                        if pd.notna(av):
                            accion = str(av).strip().upper()

                    # Tipo
                    tipo_dato = 'varchar'
                    if 'tipo_dato' in columnas_headers:
                        tv = df.iloc[i, columnas_headers['tipo_dato']]
                        if pd.notna(tv):
                            tipo_dato = str(tv).strip() or 'varchar'

                    # Tamano
                    tamano_valor = None
                    if 'tamano' in columnas_headers:
                        tv = df.iloc[i, columnas_headers['tamano']]
                        if pd.notna(tv):
                            tamano_valor = tv
                    
                    tamano_str = _parse_tamano(tamano_valor)
                    tipo_dato = _tipo_con_tamano(tipo_dato, tamano_str)
                    
                    # Convertir tipo de dato segun el motor
                    tipo_dato = get_tipo_dato_por_motor(tipo_dato, motor_bd)

                    # Generar SQL segun la accion usando sintaxis del motor
                    alter_table = get_sintaxis_alter_table(esquema, nombre_tabla, motor_bd)
                    
                    if accion in ['ADD', 'AGREGAR']:
                        add_col = get_sintaxis_add_column(nombre_col, tipo_dato, motor_bd)
                        script += f"{alter_table} {add_col};\n"
                    elif accion in ['DROP', 'ELIMINAR', 'DELETE']:
                        drop_col = get_sintaxis_drop_column(nombre_col, motor_bd)
                        script += f"{alter_table} {drop_col};\n"
                    elif accion in ['MODIFY', 'MODIFICAR', 'ALTER']:
                        modify_col = get_sintaxis_modify_column(nombre_col, tipo_dato, motor_bd)
                        script += f"{alter_table} {modify_col};\n"
                    else:
                        script += f"-- Accion desconocida '{accion}' para columna {nombre_col}\n"

        return script

    except Exception as e:
        print(f"ERROR generando script de tabla: {e}")
        import traceback
        traceback.print_exc()
        return f"-- Error generando script de tabla: {str(e)}\n-- Verifique que el archivo tenga la estructura correcta"

def generar_script_permisos_usuarios(ruta_archivo, motor_bd='postgresql'):
    """
    Genera script SQL para permisos y usuarios.
    Soporta multiples motores: postgresql, mysql, sqlserver, oracle, sqlite
    """
    # Leer archivo sin header para analizar filas
    df_original = pd.read_excel(ruta_archivo, header=None)
    
    # Buscar fila con cabecera "Esquema"
    header_row_index = None
    for idx, row in df_original.iterrows():
        if isinstance(row.iloc[0], str) and row.iloc[0].strip().lower() == 'esquema':
            header_row_index = idx
            break
    if header_row_index is None:
        raise ValueError("No se encontro la fila con la cabecera 'Esquema'")
    
    # Leer nuevamente con la fila cabecera detectada
    df = pd.read_excel(ruta_archivo, skiprows=header_row_index, header=0)
    
    # Validar columnas
    columnas_esperadas = ['Esquema', 'Nombre Tabla', 'Select', 'Insert', 'Update', 'Delete']
    for col in columnas_esperadas:
        if col not in df.columns:
            raise ValueError(f"Falta columna esperada: {col}")
    
    # Leer "Nombre Usuario" y "Es usuario Nuevo" de filas antes de la cabecera
    nombre_usuario = None
    es_usuario_nuevo = str(df_original.iloc[2,1]).strip().lower()
    
    # Intentar obtener datos
    try:
        if 'Nombre Usuario' in df_original.iloc[0, 0]:
            nombre_usuario = str(df_original.iloc[0,1]).strip()
        if 'Es usuario Nuevo' in df_original.iloc[1, 0]:
            es_usuario_nuevo = str(df_original.iloc[2,1]).strip().lower()
            print(f"DEBUG: es_usuario_nuevo: {es_usuario_nuevo}")
            if es_usuario_nuevo not in ['si', 'no']:
                raise ValueError("El valor de 'Es usuario Nuevo' debe ser 'Si' o 'No'")
    except Exception:
        pass
    print(f"DEBUG: es_usuario_nuevo: {es_usuario_nuevo}")
    if not nombre_usuario:
        raise ValueError("No se encontro el nombre de usuario en el archivo")
    if es_usuario_nuevo not in ['si', 'no']:
        raise ValueError("El valor de 'Es usuario Nuevo' debe ser 'Si' o 'NO'")
    
    # Generar scripts con encabezado del motor
    scripts = []
    scripts.append(get_encabezado_script(motor_bd))
    scripts.append(f"-- Tipo: Permisos/Usuarios")
    scripts.append(f"-- Motor: {motor_bd.upper()}")
    scripts.append(f"-- Usuario: {nombre_usuario}")
    scripts.append(f"-- Fecha: {pd.Timestamp.now().strftime('%Y-%m-%d %H:%M:%S')}\n")
    
    if es_usuario_nuevo == 'si':
        # Script para crear usuario segun motor
        scripts.append(get_sintaxis_create_user(nombre_usuario, motor_bd))
    
    # Asignar permisos segun filas
    for idx, row in df.iterrows():
        esquema = row['Esquema']
        tabla = row['Nombre Tabla']
        permisos = []
        if str(row['Select']).strip().lower() == 'si':
            permisos.append('SELECT')
        if str(row['Insert']).strip().lower() == 'si':
            permisos.append('INSERT')
        if str(row['Update']).strip().lower() == 'si':
            permisos.append('UPDATE')
        if str(row['Delete']).strip().lower() == 'si':
            permisos.append('DELETE')
        
        if permisos:
            permisos_str = ", ".join(permisos)
            scripts.append(get_sintaxis_grant(permisos_str, esquema, tabla, nombre_usuario, motor_bd))
    
    # Retornar script completo
    return "\n".join(scripts)


def generar_script_bd_esquemas(df, tipo_solicitud, base_datos, motor_bd='postgresql'):
    """
    Genera script SQL para creacion de bases de datos y esquemas
    Soporta multiples motores: postgresql, mysql, sqlserver, oracle, sqlite
    """

    try:
        # Encabezado del script
        script = get_encabezado_script(motor_bd)
        script += f"-- Tipo: {tipo_solicitud}\n"
        script += f"-- Aplicacion: {base_datos}\n"
        script += f"-- Motor: {motor_bd.upper()}\n"
        script += f"-- Fecha: {pd.Timestamp.now().strftime('%Y-%m-%d %H:%M:%S')}\n\n"

        # ===========================================
        # CASO: CREACION DE BASES DE DATOS
        # ===========================================
        if tipo_solicitud == 'crear_bd':

            # Detectar columnas que comienzan con texto tipo "Plantilla ..."
            if df.columns[0].startswith("Plantilla"):
                df.columns = ['Nombre BD', 'Charset', 'Collation']
                df = df.dropna(how='all')  # quitar filas completamente vacias

            for index, row in df.iterrows():

                nombre_bd = row.get('Nombre BD')
                if not nombre_bd or pd.isna(nombre_bd) or index < 1:
                    print(f" -> Fila {index} ignorada (vacia o invalida)")
                    continue

                charset = row.get('Charset', 'utf8mb4')
                collation = row.get('Collation', 'utf8mb4_unicode_ci')

                script += get_sintaxis_create_database(nombre_bd, charset, collation, motor_bd) + "\n"

        # ===========================================
        # CASO: CREACION DE ESQUEMAS
        # ===========================================
        elif tipo_solicitud == 'crear_esquemas':
            print(f"ANTES FOR RECORRE ROW: {tipo_solicitud}")

             # Detectar columnas que comienzan con texto tipo "Plantilla ..."
            if df.columns[0].startswith("Plantilla"):
                df.columns = ['Nombre Esquema', 'Propietario']
                df = df.dropna(how='all')  # quitar filas completamente vacias

            for index, row in df.iterrows():
                print(f"ENTRA AL FOR (fila {index}): {row.to_dict()}")

                nombre_esquema = row.get('Nombre Esquema')
                if not nombre_esquema or pd.isna(nombre_esquema) or index < 1:
                    print(f" -> Fila {index} ignorada (vacia o invalida)")
                    continue


                propietario = row.get('Propietario', 'admin')

                script += get_sintaxis_create_schema(nombre_esquema, propietario, motor_bd) + "\n"

        else:
            print(f"Tipo de solicitud no reconocido: {tipo_solicitud}")

        return script

    except Exception as e:
        return f"-- Error generando script de BD/esquemas: {str(e)}"

def generar_credenciales_usuario(solicitud):
    """
    Genera credenciales para un nuevo usuario
    """
    base_username = f"user_{solicitud.id}"
    alphabet = string.ascii_letters + string.digits + "!@#$%^&*"
    password = ''.join(secrets.choice(alphabet) for i in range(12))
    return base_username, password

def enviar_correo_notificacion(solicitud, estado, comentario=""):
    """
    Envia correo de notificacion cuando se resuelve una solicitud
    """
    try:
        subject = f"Solicitud #{solicitud.id} - {solicitud.get_estado_display()}"
        
        context = {
            'solicitud': solicitud,
            'estado': estado,
            'comentario': comentario,
        }
        
        html_content = render_to_string('emails/notificacion_resolucion.html', context)
        
        email = EmailMessage(
            subject=subject,
            body=html_content,
            from_email=settings.DEFAULT_FROM_EMAIL,
            to=[solicitud.correo_notificacion],
        )
        email.content_subtype = 'html'
        
        if solicitud.script_sql_generado and solicitud.tipo_solicitud in ['crear_tabla', 'modificar_tabla', 'crear_bd']:
            email.attach(
                f'script_solicitud_{solicitud.id}.sql',
                solicitud.script_sql_generado,
                'text/plain'
            )
        
        email.send()
        return True
        
    except Exception as e:
        print(f"Error enviando correo de notificacion: {e}")
        return False

def enviar_correo_credenciales(solicitud, usuario, password):
    """
    Envia correo con las credenciales del usuario creado
    """
    try:
        subject = f"Credenciales de acceso - Usuario creado"
        
        context = {
            'solicitud': solicitud,
            'usuario': usuario,
            'password': password,
        }
        
        html_content = render_to_string('emails/credenciales_usuario.html', context)
        
        email = EmailMessage(
            subject=subject,
            body=html_content,
            from_email=settings.DEFAULT_FROM_EMAIL,
            to=[solicitud.correo_notificacion],
        )
        email.content_subtype = 'html'
        
        email.send()
        return True
        
    except Exception as e:
        print(f"Error enviando correo de credenciales: {e}")
        return False

def enviar_correo_aprobacion_lider(solicitud):
    """
    Envia correo al lider de proyecto para aprobacion de creacion de usuario
    """
    try:
        subject = f"Aprobacion requerida - Solicitud #{solicitud.id}"
        
        context = {
            'solicitud': solicitud,
            'url_detalle': f"{settings.SITE_URL}/solicitud/{solicitud.id}/",
        }
        
        html_content = render_to_string('emails/aprobacion_lider.html', context)
        
        email = EmailMessage(
            subject=subject,
            body=html_content,
            from_email=settings.DEFAULT_FROM_EMAIL,
            to=[solicitud.lider_proyecto.email],
        )
        email.content_subtype = 'html'
        
        email.send()
        return True
        
    except Exception as e:
        print(f"Error enviando correo de aprobacion: {e}")
        return False

def enviar_correo_cambio_estado(solicitud, estado_anterior, estado_nuevo, usuario_cambio, comentario=""):
    """
    Envia correo de notificacion cuando cambia el estado de una solicitud
    """
    try:
        destinatarios = [solicitud.correo_notificacion]
        
        if usuario_cambio != solicitud.usuario and solicitud.usuario.email:
            destinatarios.append(solicitud.usuario.email)
        
        if (solicitud.lider_proyecto and solicitud.lider_proyecto.email and 
            solicitud.lider_proyecto != usuario_cambio):
            destinatarios.append(solicitud.lider_proyecto.email)
        
        destinatarios = list(set(destinatarios))
        
        subject = f"Cambio de Estado - Solicitud #{solicitud.id}"
        
        context = {
            'solicitud': solicitud,
            'estado_anterior': dict(solicitud.ESTADOS)[estado_anterior],
            'estado_nuevo': dict(solicitud.ESTADOS)[estado_nuevo],
            'usuario_cambio': usuario_cambio,
            'comentario': comentario,
        }
        
        html_content = render_to_string('emails/notificacion_resolucion.html', context)
        
        email = EmailMessage(
            subject=subject,
            body=html_content,
            from_email=settings.DEFAULT_FROM_EMAIL,
            to=destinatarios,
        )
        email.content_subtype = 'html'
        
        email.send()
        return True
        
    except Exception as e:
        print(f"Error enviando correo de cambio de estado: {e}")
        return False

def generar_script_sql(solicitud):
    """
    Funcion principal para generar scripts SQL basados en el tipo de solicitud
    """
    if solicitud.tipo_solicitud in ['pull_request', 'despliegue']:
        script = f"-- Solicitud de {solicitud.get_tipo_solicitud_display()}\n"
        script += f"-- Base de datos/Aplicacion: {solicitud.base_datos_aplicacion}\n"
        script += f"-- URL: {solicitud.url_commit}\n"
        script += f"-- Branch: {solicitud.nombre_branch}\n"
        script += f"-- Entorno: {solicitud.entorno}\n"
        if solicitud.ambientes_ejecucion:
            script += f"-- Ambientes de ejecucion: {', '.join(solicitud.ambientes_ejecucion)}\n"
        return script

    if solicitud.archivo_adjunto and solicitud.tipo_archivo == 'excel':
        return procesar_archivo_excel(solicitud)

    return None


# =========================
# Helpers de tamano
# =========================
def _parse_tamano(valor):
    """
    Devuelve un string valido para usar en parentesis del tipo (ej. '20' o '10,2'),
    o None si no es valido/proporcionado.
    """
    if valor is None or (isinstance(valor, float) and pd.isna(valor)):
        return None

    # Numero simple
    if isinstance(valor, (int, float)) and not isinstance(valor, bool):
        if float(valor).is_integer():
            return str(int(valor))
        # numeros flotantes no sirven como tamano (excepto decimales NN,MM)
        return None

    s = str(valor).strip()
    if not s:
        return None

    # limpiar separadores raros
    s = s.replace(' ', '')
    s = s.replace(';', ',').replace(':', ',').replace('/', ',')

    # convertir "10.2" -> "10,2" si no hay comas
    if s.count('.') == 1 and ',' not in s:
        s = s.replace('.', ',')

    # solo permitir: NN o NN,MM
    if re.fullmatch(r'\d+(,\d+)?', s):
        return s
    return None


def _tipo_con_tamano(tipo_dato, tamano_str):
    """
    Inserta (tamano) a tipos que lo aceptan si el tipo no trae parentesis.
    """
    t = str(tipo_dato).strip()
    if not t:
        return t
    if '(' in t:
        return t
    if not tamano_str:
        return t

    base = t.lower()
    acepta = ('character varying', 'varchar', 'character', 'char', 'numeric', 'decimal', 'nvarchar', 'varchar2')
    if any(base.startswith(a) for a in acepta):
        return f"{t}({tamano_str})"
    return t

def crear_plantilla_excel(tipo_solicitud):
    """
    Genera una plantilla Excel base con formato visual uniforme
    para tipos de solicitud: crear_bd, crear_esquemas, crear_tabla, etc.
    """
    # Ruta base de guardado
    output_dir = os.path.join(settings.MEDIA_ROOT, "plantillas")
    os.makedirs(output_dir, exist_ok=True)

    # Crear workbook
    wb = Workbook()
    ws = wb.active

    # Configuracion segun tipo
    if tipo_solicitud == "crear_bd":
        titulo = "Plantilla Creacion de Base de Datos"
        headers = ["Nombre BD", "Charset", "Collation"]
        filename = "plantilla_creacion_bd.xlsx"
    elif tipo_solicitud == "crear_esquemas":
        titulo = "Plantilla Creacion de Esquemas"
        headers = ["Nombre Esquema", "Propietario"]
        filename = "plantilla_creacion_esquemas.xlsx"
    else:
        raise ValueError("Tipo de solicitud no soportado para generacion de plantilla")

    # Encabezado principal
    ws.merge_cells("A1:C1")
    ws["A1"] = titulo
    ws["A1"].font = Font(bold=True, size=14)
    ws["A1"].alignment = Alignment(horizontal="center")

    # Fila de headers
    ws.append(headers)
    _formatear_encabezados(ws)

    # Ajustar ancho de columnas (ignorando la fila del titulo)
    for idx, col_cells in enumerate(ws.iter_cols(min_row=2, max_row=2), start=1):
        col_letter = ws.cell(row=2, column=idx).column_letter
        ws.column_dimensions[col_letter].width = 25

    # Guardar archivo
    path = os.path.join(output_dir, filename)
    wb.save(path)
    return path


def _formatear_encabezados(ws):
    """Aplica formato visual uniforme a los encabezados"""
    bold = Font(bold=True)
    center = Alignment(horizontal="center", vertical="center")
    border = Border(
        left=Side(style="thin"),
        right=Side(style="thin"),
        top=Side(style="thin"),
        bottom=Side(style="thin"),
    )
    fill = PatternFill(start_color="D9E1F2", end_color="D9E1F2", fill_type="solid")
    for cell in ws[2]:
        cell.font = bold
        cell.alignment = center
        cell.border = border
        cell.fill = fill
